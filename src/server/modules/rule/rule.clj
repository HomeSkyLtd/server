;;#Rule Module

;;This module contains functions to add rules, get rules provided by the machine learning 
;;algorithms, accept these rules by the users and remove rules that doesn't please them.

(ns server.modules.rule.rule
	(:require [server.db :as db]
			  [server.utils :as utils]))

;;##Private function

(defn- coll-name 
	"Return the collection name for a specific house."
	[houseId] (str "rules_" houseId))

;;Auxiliar functions to count the number of new rules per controller

(defn list-controller-ids
	"Return a list of distinct controller ids"
	[rules]
	(distinct (map #(:controllerId %) rules)))

(defn build-count
	"Count the number of new rules for a given controllerId"
	[rules controllerId]
	{
		:notification "newRules"
	 	:quantity (count (filter #(= controllerId (:controllerId %)) rules))
	}
)

(defn- notify-new-rules
	"Notification sent via web socket from server to controller with new rules accepted by the user
	and the rules inserted by the user."
	[rules]
	(let [list-of-ids (list-controller-ids rules)]
		(map 
			#(handler/send-websocket-notification! % (build-count rules %))
			list-of-ids
		)
	)
)


;;##Public functions

(defn new-rules
	"Insert rules into database. These rules are those defined in the App, 
	so are already accepted by the user."
	[obj houseId agentId]
	(if-let [rules (:rules obj)]
		(if (every? true? (map #(and (contains? % :nodeId) (contains? % :commandId) (contains? % :controllerId)  (contains? % :value) (contains? % :clauses)) rules))
				(if (every? true? 
					(map  #(db/insert? (coll-name houseId) (assoc % :accepted 1)) rules))
					{:status 200}
					{:status 500 :errorMessage "DB did not insert values."}
				)
				{:status 400 :errorMessage "Define nodeId, controllerId, commandId, value and clauses."}
		)
		{:status 400 :errorMessage "Rules not defined"}
	)
)

(defn get-rules 
	"Select rules from db that were generated and already accepted by the users."
	[_ houseId _]
	{:status 200 :rules (into [] (map #(dissoc % :_id) (db/select (coll-name houseId) {:accepted 1})))}
)

(defn get-learnt-rules
	"Select rules from db that were generated by the Machine Learning algorithms."
	[_ houseId _]
	{:status 200 
	 :rules (into [] (map 
					   #(assoc 
					 		(dissoc % :_id :nodeId :commandId :value :accepted) 
					 		:command (select-keys % [:nodeId :commandId :value])
					 	)
					 	(db/select (coll-name houseId) {:accepted 0})
					 )
			)
	}
)

(defn accept-rule
	"Accepted a new rule by the users generated by the Machine Learning algorithms."
	[obj houseId _]
	(let [key-vals (select-keys obj [:nodeId :controllerId :commandId :value])
		  result (db/select (coll-name houseId) (merge key-vals {:accepted 1}))]
		(if (empty? result)
			(if (db/update? (coll-name houseId) key-vals :set {:accepted 1})
				{:status 200}
				{:status 500 :errorMessage "DB did not update value."}
			)
			{:status 200 :conflictingRule result}
		)
	)
)

(defn remove-rule
	"Remove a rule from database selected by nodeId, controllerId, commandId and value."
	[obj houseId _]
	(let [key-vals (select-keys obj [:nodeId :controllerId :commandId :value])]
		(if (empty? (db/select (coll-name houseId) key-vals))
			{:status 400 :errorMessage "DB does not contain obj."}
			(if (db/remove? (coll-name houseId) (assoc key-vals :accepted 1))
				{:status 200}
				{:status 500 :errorMessage "DB did not remove value."}
			)
		)
	)
)

;;
;;##Notification functions
;;

(defn notify-learnt-rules
	"Send a notification to user's device with new learnt rules."
	[houseId tokens msg]
	(utils/send-notification (tokens houseId) msg))